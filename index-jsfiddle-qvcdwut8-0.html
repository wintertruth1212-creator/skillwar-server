<!DOCTYPE html>
<html>

<html>
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>Skill War Online</title>

  <style>
    * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Arial', sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            color: #333;
        }

        .container {
            max-width: 1200px;
            margin: 0 auto;
            padding: 20px;
        }

        .game-header {
            text-align: center;
            margin-bottom: 30px;
        }

        .game-title {
            font-size: 3em;
            color: #fff;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.3);
            margin-bottom: 10px;
        }

        .game-status {
            background: rgba(255,255,255,0.9);
            padding: 15px;
            border-radius: 10px;
            margin-bottom: 20px;
            box-shadow: 0 4px 6px rgba(0,0,0,0.1);
        }

        .players-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
            gap: 20px;
            margin-bottom: 30px;
        }

        .player-card {
            background: rgba(255,255,255,0.95);
            border-radius: 15px;
            padding: 20px;
            box-shadow: 0 8px 16px rgba(0,0,0,0.1);
            transition: transform 0.3s ease;
        }

        .player-card:hover {
            transform: translateY(-5px);
        }

        .player-card.current-turn {
            border: 3px solid #ff6b6b;
            box-shadow: 0 0 20px rgba(255,107,107,0.5);
            animation: pulse 2s infinite;
        }

        @keyframes pulse {
            0% { box-shadow: 0 0 20px rgba(255,107,107,0.5); }
            50% { box-shadow: 0 0 30px rgba(255,107,107,0.8); }
            100% { box-shadow: 0 0 20px rgba(255,107,107,0.5); }
        }

        .player-card.dead {
            background: rgba(0,0,0,0.8);
            color: #fff;
        }

        .player-name {
            font-size: 1.2em;
            font-weight: bold;
            margin-bottom: 10px;
            color: #4a5568;
        }

        .player-hp {
            font-size: 1.5em;
            color: #e53e3e;
            margin-bottom: 10px;
        }

        .player-status {
            margin: 10px 0;
        }

        .status-effects {
            display: flex;
            gap: 5px;
            margin-top: 10px;
            flex-wrap: wrap;
        }

        .status-effect {
            padding: 4px 8px;
            border-radius: 15px;
            font-size: 0.8em;
            color: #fff;
        }

        .fire { background-color: #ff4444; }
        .water { background-color: #4444ff; }
        .wind { background-color: #44ff44; }
        .earth { background-color: #8b4513; }
        .thunder { background-color: #ffff00; color: #000; }
        .ice { background-color: #87ceeb; }

        .hand-cards {
            background: rgba(255,255,255,0.9);
            padding: 20px;
            border-radius: 15px;
            margin-bottom: 20px;
        }

        .cards-container {
            display: flex;
            gap: 10px;
            overflow-x: auto;
            padding: 10px 0;
        }

        .card {
            min-width: 150px;
            background: linear-gradient(135deg, #f093fb 0%, #f5576c 100%);
            border-radius: 10px;
            padding: 15px;
            color: #fff;
            cursor: pointer;
            transition: transform 0.3s ease;
            box-shadow: 0 4px 8px rgba(0,0,0,0.2);
        }

        .card:hover {
            transform: scale(1.05);
        }

        .card.selected {
            border: 3px solid #ffd700;
            transform: scale(1.1);
        }

        .card-name {
            font-weight: bold;
            margin-bottom: 5px;
        }

        .card-description {
            font-size: 0.8em;
            margin-bottom: 10px;
        }

        .card-damage {
            color: #ffeb3b;
            font-weight: bold;
        }

        .actions-panel {
            background: rgba(255,255,255,0.9);
            padding: 20px;
            border-radius: 15px;
            text-align: center;
        }

        .action-buttons {
            display: flex;
            gap: 15px;
            justify-content: center;
            margin-bottom: 20px;
        }

        .btn {
            padding: 12px 24px;
            border: none;
            border-radius: 25px;
            cursor: pointer;
            font-size: 1em;
            font-weight: bold;
            transition: all 0.3s ease;
            box-shadow: 0 4px 8px rgba(0,0,0,0.2);
        }

        .btn-primary {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
        }

        .btn-secondary {
            background: linear-gradient(135deg, #f093fb 0%, #f5576c 100%);
            color: white;
        }

        .btn-success {
            background: linear-gradient(135deg, #4facfe 0%, #00f2fe 100%);
            color: white;
        }

        .btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 12px rgba(0,0,0,0.3);
        }

        .btn:disabled {
            opacity: 0.5;
            cursor: not-allowed;
            transform: none;
        }

        .target-selection {
            margin: 20px 0;
        }

        .target-players {
            display: flex;
            gap: 10px;
            justify-content: center;
            flex-wrap: wrap;
        }

        .target-player {
            padding: 10px 20px;
            background: #4a5568;
            color: white;
            border: none;
            border-radius: 20px;
            cursor: pointer;
            transition: all 0.3s ease;
        }

        .target-player:hover {
            background: #2d3748;
            transform: scale(1.05);
        }

        .target-player.selected {
            background: #e53e3e;
        }

        .room-setup {
            background: rgba(255,255,255,0.95);
            padding: 30px;
            border-radius: 15px;
            text-align: center;
            margin-bottom: 20px;
        }

        .room-input {
            margin: 10px;
            padding: 10px;
            border: 2px solid #ddd;
            border-radius: 5px;
            font-size: 1em;
            width: 200px;
        }

        .room-list {
            background: rgba(255,255,255,0.9);
            padding: 20px;
            border-radius: 15px;
            margin-bottom: 20px;
        }

        .room-item {
            background: rgba(106, 90, 205, 0.1);
            padding: 15px;
            margin: 10px 0;
            border-radius: 10px;
            border-left: 4px solid #6a5acd;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .room-info {
            flex: 1;
        }

        .room-name {
            font-weight: bold;
            color: #4a5568;
        }

        .room-players {
            color: #666;
            font-size: 0.9em;
        }

        .waiting-room {
            background: rgba(255,255,255,0.95);
            padding: 30px;
            border-radius: 15px;
            text-align: center;
        }

        .players-list {
            background: rgba(248, 249, 250, 0.8);
            padding: 20px;
            border-radius: 10px;
            margin: 20px 0;
        }

        .player-item {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 10px;
            margin: 5px 0;
            background: rgba(255,255,255,0.8);
            border-radius: 8px;
        }

        .player-ready {
            color: #48bb78;
            font-weight: bold;
        }

        .player-waiting {
            color: #ed8936;
        }

        .connection-status {
            position: fixed;
            top: 20px;
            right: 20px;
            padding: 10px 15px;
            border-radius: 20px;
            font-weight: bold;
            z-index: 1000;
        }

        .connected {
            background: #48bb78;
            color: white;
        }

        .disconnected {
            background: #e53e3e;
            color: white;
        }

        .turn-timer {
            background: rgba(255,107,107,0.9);
            color: white;
            padding: 15px;
            border-radius: 10px;
            text-align: center;
            font-size: 1.2em;
            font-weight: bold;
            margin-bottom: 20px;
        }

        .game-log {
            background: rgba(0,0,0,0.8);
            color: #fff;
            padding: 15px;
            border-radius: 10px;
            max-height: 200px;
            overflow-y: auto;
            margin-bottom: 20px;
        }

        .log-entry {
            margin: 5px 0;
            padding: 3px 0;
            border-bottom: 1px solid rgba(255,255,255,0.2);
        }

        .ghost-panel {
            background: rgba(0,0,0,0.9);
            color: #fff;
            padding: 20px;
            border-radius: 15px;
            text-align: center;
            margin-bottom: 20px;
        }

        .ghost-title {
            font-size: 1.5em;
            margin-bottom: 10px;
            color: #ff6b6b;
        }

        .possess-targets {
            display: flex;
            gap: 10px;
            justify-content: center;
            flex-wrap: wrap;
            margin-top: 15px;
        }

        .action-feedback {
            background: rgba(72, 187, 120, 0.9);
            color: white;
            padding: 10px;
            border-radius: 8px;
            margin: 10px 0;
            text-align: center;
            animation: fadeInOut 3s ease-in-out;
        }

        .error-feedback {
            background: rgba(229, 62, 62, 0.9);
        }

        @keyframes fadeInOut {
            0% { opacity: 0; transform: translateY(-10px); }
            20% { opacity: 1; transform: translateY(0); }
            80% { opacity: 1; transform: translateY(0); }
            100% { opacity: 0; transform: translateY(-10px); }
        }

        .server-info {
            background: rgba(255,255,255,0.9);
            padding: 15px;
            border-radius: 10px;
            margin-bottom: 20px;
            text-align: center;
            font-size: 0.9em;
            color: #666;
        }
  </style>

  
</head>
<body>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/socket.io/4.7.2/socket.io.js"></script>
    


    <div class="connection-status" id="connection-status">
        <span id="connection-text">æ¥ç¶šä¸­...</span>
    </div>

    <div class="container">
        <div class="game-header">
            <h1 class="game-title">âš”ï¸ Skill War Online âš”ï¸</h1>
        </div>

        <div class="server-info">
            <p><strong>ã‚µãƒ¼ãƒãƒ¼æ¥ç¶š:</strong> <span id="server-url">wss://skillwar-server.herokuapp.com</span></p>
            <p>ãƒªã‚¢ãƒ«ã‚¿ã‚¤ãƒ é€šä¿¡ã§ãƒãƒ«ãƒãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ã‚²ãƒ¼ãƒ ã‚’æ¥½ã—ã‚‚ã†ï¼</p>
        </div>

        <!-- éƒ¨å±‹é¸æŠ/ä½œæˆç”»é¢ -->
        <div id="room-screen" class="room-setup">
            <h2>ğŸŒ ã‚ªãƒ³ãƒ©ã‚¤ãƒ³ãƒãƒƒãƒãƒ³ã‚°</h2>
            
            <div style="margin: 30px 0;">
                <h3>æ–°ã—ã„éƒ¨å±‹ã‚’ä½œæˆ</h3>
                <input type="text" id="player-name" class="room-input" placeholder="ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼å" value="ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼1">
                <input type="text" id="room-name" class="room-input" placeholder="éƒ¨å±‹å" value="">
                <br>
                <label>æœ€å¤§äººæ•°ï¼š</label>
                <select id="max-players" class="room-input">
                    <option value="2">2äºº</option>
                    <option value="3">3äºº</option>
                    <option value="4" selected>4äºº</option>
                    <option value="5">5äºº</option>
                    <option value="6">6äºº</option>
                </select>
                <br>
                <button onclick="createRoom()" class="btn btn-primary">éƒ¨å±‹ä½œæˆ</button>
            </div>

            <div class="room-list">
                <h3>åˆ©ç”¨å¯èƒ½ãªéƒ¨å±‹</h3>
                <div id="available-rooms">
                    <p>éƒ¨å±‹ã‚’æ¤œç´¢ä¸­...</p>
                </div>
                <button onclick="refreshRooms()" class="btn btn-secondary">æ›´æ–°</button>
            </div>

            <div style="margin-top: 20px;">
                <h3>éƒ¨å±‹IDã§å‚åŠ </h3>
                <input type="text" id="room-id-input" class="room-input" placeholder="éƒ¨å±‹ID">
                <button onclick="joinRoomById()" class="btn btn-secondary">å‚åŠ </button>
            </div>
        </div>

        <!-- å¾…æ©Ÿå®¤ç”»é¢ -->
        <div id="waiting-screen" style="display: none;" class="waiting-room">
            <h2 id="room-title">éƒ¨å±‹å</h2>
            <div id="room-code" style="font-size: 1.2em; margin: 10px 0; color: #666;"></div>
            
            <div class="players-list">
                <h3>å‚åŠ ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼</h3>
                <div id="players-in-room"></div>
            </div>

            <div style="margin: 20px 0;">
                <button id="ready-toggle" onclick="toggleReady()" class="btn btn-success">æº–å‚™å®Œäº†</button>
                <button onclick="leaveRoom()" class="btn btn-secondary">éƒ¨å±‹ã‚’å‡ºã‚‹</button>
            </div>

            <div id="start-game-section" style="display: none;">
                <button onclick="startOnlineGame()" class="btn btn-primary">ğŸš€ ã‚²ãƒ¼ãƒ é–‹å§‹ï¼</button>
            </div>
        </div>

        <!-- ã‚²ãƒ¼ãƒ ç”»é¢ -->
        <div id="game-screen" style="display: none;">
            <div id="turn-timer" class="turn-timer" style="display: none;">
                â° æ®‹ã‚Šæ™‚é–“: <span id="timer-seconds">30</span>ç§’
            </div>

            <div class="game-status">
                <div><strong>ã‚¿ãƒ¼ãƒ³:</strong> <span id="current-turn">1</span></div>
                <div><strong>ç¾åœ¨ã®ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼:</strong> <span id="current-player-name">-</span></div>
                <div><strong>éƒ¨å±‹:</strong> <span id="current-room-name">-</span></div>
                <div><strong>ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ID:</strong> <span id="my-player-id">-</span></div>
            </div>

            <div class="game-log" id="game-log">
                <div class="log-entry">ã‚²ãƒ¼ãƒ ãŒé–‹å§‹ã•ã‚Œã¾ã—ãŸï¼</div>
            </div>

            <div class="players-grid" id="players-grid"></div>

            <div id="ghost-panel" class="ghost-panel" style="display: none;">
                <div class="ghost-title">ğŸ‘» ã‚ãªãŸã¯äº¡éœŠã«ãªã‚Šã¾ã—ãŸ ğŸ‘»</div>
                <div>å±æ€§: <span id="ghost-element"></span></div>
                <div>ç”Ÿãã¦ã„ã‚‹ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ã«å–ã‚Šæ†‘ãã“ã¨ãŒã§ãã¾ã™</div>
                <div class="possess-targets" id="possess-targets"></div>
            </div>

            <div id="player-hand" class="hand-cards">
                <h3>æ‰‹æœ­ (<span id="hand-count">0</span>æš)</h3>
                <div class="cards-container" id="hand-cards"></div>
            </div>

            <div class="actions-panel">
                <div id="action-feedback"></div>
                
                <div class="action-buttons">
                    <button id="use-card-btn" class="btn btn-primary" onclick="selectAction('useCard')">ã‚«ãƒ¼ãƒ‰ã‚’ä½¿ã†</button>
                    <button id="draw-card-btn" class="btn btn-secondary" onclick="selectAction('drawCard')">ã‚«ãƒ¼ãƒ‰ã‚’å¼•ã</button>
                </div>

                <div id="target-selection" class="target-selection" style="display: none;">
                    <h4>ã‚¿ãƒ¼ã‚²ãƒƒãƒˆã‚’é¸æŠã—ã¦ãã ã•ã„ï¼š</h4>
                    <div class="target-players" id="target-players"></div>
                </div>

                <button id="confirm-action-btn" class="btn btn-success" onclick="confirmAction()" style="display: none;">ã‚¢ã‚¯ã‚·ãƒ§ãƒ³å®Ÿè¡Œ</button>
            </div>

            <div id="game-over-screen" style="display: none;" class="room-setup">
                <h2>ğŸ† ã‚²ãƒ¼ãƒ çµ‚äº† ğŸ†</h2>
                <div id="final-ranking"></div>
                <button onclick="backToRooms()" class="btn btn-primary">éƒ¨å±‹ä¸€è¦§ã«æˆ»ã‚‹</button>
            </div>
        </div>
    </div>

  <script>
    // ã‚°ãƒ­ãƒ¼ãƒãƒ«å¤‰æ•°
        let socket = null;
        let gameState = {
            phase: 'rooms',
            currentRoom: null,
            currentPlayer: null,
            players: [],
            currentPlayerIndex: 0,
            turnNumber: 1,
            selectedCard: null,
            selectedTarget: null,
            isMyTurn: false,
            turnTimeLeft: 30,
            turnTimer: null,
            playerId: null
        };

        // å±æ€§å®šæ•°
        const ELEMENTS = {
            FIRE: 'fire',
            WATER: 'water',
            WIND: 'wind',
            EARTH: 'earth',
            THUNDER: 'thunder',
            ICE: 'ice'
        };

        const ELEMENT_NAMES = {
            [ELEMENTS.FIRE]: 'ç‚',
            [ELEMENTS.WATER]: 'æ°´',
            [ELEMENTS.WIND]: 'é¢¨',
            [ELEMENTS.EARTH]: 'åœŸ',
            [ELEMENTS.THUNDER]: 'é›·',
            [ELEMENTS.ICE]: 'æ°·'
        };

        // å±æ€§ç›¸æ€§ã‚·ã‚¹ãƒ†ãƒ 
        const ELEMENT_REACTIONS = {
            [`${ELEMENTS.FIRE},${ELEMENTS.WATER}`]: { name: 'è’¸ç™º', effect: 'steam' },
            [`${ELEMENTS.WATER},${ELEMENTS.FIRE}`]: { name: 'è’¸ç™º', effect: 'steam' },
            [`${ELEMENTS.THUNDER},${ELEMENTS.WATER}`]: { name: 'æ„Ÿé›»', effect: 'shock' },
            [`${ELEMENTS.WATER},${ELEMENTS.THUNDER}`]: { name: 'æ„Ÿé›»', effect: 'shock' },
            [`${ELEMENTS.FIRE},${ELEMENTS.WIND}`]: { name: 'ç‡ƒç„¼', effect: 'burn' },
            [`${ELEMENTS.WIND},${ELEMENTS.FIRE}`]: { name: 'ç‡ƒç„¼', effect: 'burn' },
            [`${ELEMENTS.THUNDER},${ELEMENTS.FIRE}`]: { name: 'éå‰°åå¿œ', effect: 'overreaction' },
            [`${ELEMENTS.FIRE},${ELEMENTS.THUNDER}`]: { name: 'éå‰°åå¿œ', effect: 'overreaction' },
            [`${ELEMENTS.ICE},${ELEMENTS.FIRE}`]: { name: 'æº¶è§£', effect: 'melt' },
            [`${ELEMENTS.FIRE},${ELEMENTS.ICE}`]: { name: 'æº¶è§£', effect: 'melt' },
            [`${ELEMENTS.WATER},${ELEMENTS.EARTH}`]: { name: 'æº¶è§£', effect: 'dissolve' },
            [`${ELEMENTS.EARTH},${ELEMENTS.WATER}`]: { name: 'æº¶è§£', effect: 'dissolve' },
            [`${ELEMENTS.EARTH},${ELEMENTS.WIND}`]: { name: 'é¢¨åŒ–', effect: 'erosion' },
            [`${ELEMENTS.WIND},${ELEMENTS.EARTH}`]: { name: 'é¢¨åŒ–', effect: 'erosion' }
        };

        // ã‚«ãƒ¼ãƒ‰ãƒ‡ãƒ¼ã‚¿ãƒ™ãƒ¼ã‚¹
        const CARD_DATABASE = [
            // ç‚å±æ€§ã‚«ãƒ¼ãƒ‰
            { id: 1, name: 'ç«ã®ç‰', element: ELEMENTS.FIRE, damage: 2, description: 'åŸºæœ¬çš„ãªç‚æ”»æ’ƒ' },
            { id: 2, name: 'æ¥­ç«', element: ELEMENTS.FIRE, damage: 3, description: 'å¼·åŠ›ãªç‚æ”»æ’ƒ' },
            { id: 3, name: 'ç«ç‚æ”¾å°„', element: ELEMENTS.FIRE, damage: 4, description: 'ç¯„å›²æ”»æ’ƒ' },
            { id: 4, name: 'çˆ†ç‚', element: ELEMENTS.FIRE, damage: 5, description: 'æœ€å¼·ã®ç‚æ”»æ’ƒ' },
            { id: 5, name: 'ç‚ã®å£', element: ELEMENTS.FIRE, damage: 1, description: 'é˜²å¾¡åŠ¹æœä»˜ã' },
            
            // æ°´å±æ€§ã‚«ãƒ¼ãƒ‰
            { id: 6, name: 'æ°´æµ', element: ELEMENTS.WATER, damage: 2, description: 'åŸºæœ¬çš„ãªæ°´æ”»æ’ƒ' },
            { id: 7, name: 'é«˜åœ§æ”¾æ°´', element: ELEMENTS.WATER, damage: 3, description: 'å¼·åŠ›ãªæ°´æ”»æ’ƒ' },
            { id: 8, name: 'æ´¥æ³¢', element: ELEMENTS.WATER, damage: 4, description: 'å…¨ä½“æ”»æ’ƒ' },
            { id: 9, name: 'æ°´ã®ç™’ã—', element: ELEMENTS.WATER, damage: 0, description: 'HP2å›å¾©' },
            { id: 10, name: 'å‡çµ', element: ELEMENTS.WATER, damage: 1, description: 'è¡Œå‹•ä¸å¯åŠ¹æœ' },
            
            // é¢¨å±æ€§ã‚«ãƒ¼ãƒ‰
            { id: 11, name: 'çªé¢¨', element: ELEMENTS.WIND, damage: 2, description: 'åŸºæœ¬çš„ãªé¢¨æ”»æ’ƒ' },
            { id: 12, name: 'ç«œå·»', element: ELEMENTS.WIND, damage: 3, description: 'æ‰‹æœ­ã‚·ãƒ£ãƒƒãƒ•ãƒ«' },
            { id: 13, name: 'åµ', element: ELEMENTS.WIND, damage: 4, description: 'æ‰‹æœ­ç ´æ£„åŠ¹æœ' },
            { id: 14, name: 'ç–¾é¢¨', element: ELEMENTS.WIND, damage: 1, description: 'ã‚«ãƒ¼ãƒ‰ãƒ‰ãƒ­ãƒ¼' },
            { id: 15, name: 'é¢¨ã®åŠ è­·', element: ELEMENTS.WIND, damage: 0, description: 'çŠ¶æ…‹ç•°å¸¸è§£é™¤' },
            
            // åœŸå±æ€§ã‚«ãƒ¼ãƒ‰
            { id: 16, name: 'å²©çŸ³æŠ•ã’', element: ELEMENTS.EARTH, damage: 2, description: 'åŸºæœ¬çš„ãªåœŸæ”»æ’ƒ' },
            { id: 17, name: 'åœ°éœ‡', element: ELEMENTS.EARTH, damage: 3, description: 'å…¨ä½“æ”»æ’ƒ' },
            { id: 18, name: 'è½çŸ³', element: ELEMENTS.EARTH, damage: 4, description: 'è¡Œå‹•å°å°' },
            { id: 19, name: 'åœŸã®å£', element: ELEMENTS.EARTH, damage: 0, description: 'HPå¢—åŠ ' },
            { id: 20, name: 'ç ‚åµ', element: ELEMENTS.EARTH, damage: 1, description: 'è¦–ç•Œå¦¨å®³' },
            
            // é›·å±æ€§ã‚«ãƒ¼ãƒ‰
            { id: 21, name: 'é›·æ’ƒ', element: ELEMENTS.THUNDER, damage: 2, description: 'åŸºæœ¬çš„ãªé›·æ”»æ’ƒ' },
            { id: 22, name: 'è½é›·', element: ELEMENTS.THUNDER, damage: 4, description: 'éº»ç—ºåŠ¹æœ' },
            { id: 23, name: 'ç¨²å¦»', element: ELEMENTS.THUNDER, damage: 3, description: 'é€£é–æ”»æ’ƒ' },
            { id: 24, name: 'é›»æ’ƒç¶²', element: ELEMENTS.THUNDER, damage: 1, description: 'å…¨ä½“æ”»æ’ƒ' },
            { id: 25, name: 'å……é›»', element: ELEMENTS.THUNDER, damage: 0, description: 'æ¬¡å›ãƒ€ãƒ¡ãƒ¼ã‚¸å¼·åŒ–' },
            
            // æ°·å±æ€§ã‚«ãƒ¼ãƒ‰
            { id: 26, name: 'æ°·ã®çŸ¢', element: ELEMENTS.ICE, damage: 2, description: 'åŸºæœ¬çš„ãªæ°·æ”»æ’ƒ' },
            { id: 27, name: 'å¹é›ª', element: ELEMENTS.ICE, damage: 3, description: 'è¡Œå‹•é€Ÿåº¦ä½ä¸‹' },
            { id: 28, name: 'æ°·æ²³', element: ELEMENTS.ICE, damage: 4, description: 'é•·æ™‚é–“å‡çµ' },
            { id: 29, name: 'éœœ', element: ELEMENTS.ICE, damage: 1, description: 'ãƒ€ãƒ¡ãƒ¼ã‚¸æ¸›å°‘' },
            { id: 30, name: 'æ°·ã®ç›¾', element: ELEMENTS.ICE, damage: 0, description: 'æ”»æ’ƒç„¡åŠ¹åŒ–' }
        ];

        // ã‚µãƒ¼ãƒãƒ¼æ¥ç¶š
        function initializeSocket() {
            // å®Ÿéš›ã®ãƒ—ãƒ­ãƒ€ã‚¯ã‚·ãƒ§ãƒ³ã§ã¯å®Ÿéš›ã®ã‚µãƒ¼ãƒãƒ¼URLã‚’ä½¿ç”¨
            const serverUrl = 'wss://skillwar-server.onrender.com';
            
            try {
                socket = io(serverUrl, {
                    transports: ['websocket', 'polling'],
                    upgrade: true,
                    rememberUpgrade: true
                });

                setupSocketListeners();
            } catch (error) {
                console.warn('WebSocketã‚µãƒ¼ãƒãƒ¼ã«æ¥ç¶šã§ãã¾ã›ã‚“ã§ã—ãŸã€‚ãƒ‡ãƒ¢ãƒ¢ãƒ¼ãƒ‰ã§å‹•ä½œã—ã¾ã™ã€‚');
                initializeDemoMode();
            }
        }

        function initializeDemoMode() {
            // ãƒ‡ãƒ¢ãƒ¢ãƒ¼ãƒ‰: ãƒ­ãƒ¼ã‚«ãƒ«ã§ã®ã‚·ãƒŸãƒ¥ãƒ¬ãƒ¼ã‚·ãƒ§ãƒ³
            socket = new EventTarget();
            socket.connected = false;
            
            // WebSocketã®ãƒ¡ã‚½ãƒƒãƒ‰ã‚’ã‚·ãƒŸãƒ¥ãƒ¬ãƒ¼ãƒˆ
            socket.emit = function(event, data) {
                setTimeout(() => {
                    handleDemoEvent(event, data);
                }, Math.random() * 1000 + 500);
            };

            socket.on = function(event, callback) {
                this.addEventListener(event, (e) => {
                    callback(e.detail);
                });
            };

            updateConnectionStatus(false);
            showActionFeedback('ãƒ‡ãƒ¢ãƒ¢ãƒ¼ãƒ‰ã§å‹•ä½œä¸­ï¼ˆã‚ªãƒ•ãƒ©ã‚¤ãƒ³ï¼‰', 'error');
        }

        function handleDemoEvent(event, data) {
            switch (event) {
                case 'createRoom':
                    const room = {
                        id: generateRoomId(),
                        name: data.roomName,
                        maxPlayers: data.maxPlayers,
                        players: [data.player],
                        isStarted: false
                    };
                    gameState.currentRoom = room;
                    gameState.currentPlayer = data.player;
                    socket.dispatchEvent(new CustomEvent('roomCreated', { detail: { room, player: data.player } }));
                    break;
                    
                case 'joinRoom':
                    // ãƒ‡ãƒ¢ç”¨ã®è‡ªå‹•NPCãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼è¿½åŠ 
                    const demoRoom = {
                        id: data.roomId,
                        name: 'ãƒ‡ãƒ¢ãƒ«ãƒ¼ãƒ ',
                        maxPlayers: 4,
                        players: [
                            { id: 'demo1', name: 'ãƒ‡ãƒ¢ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼1', isReady: false, isHost: true, index: 0 },
                            data.player
                        ],
                        isStarted: false
                    };
                    gameState.currentRoom = demoRoom;
                    gameState.currentPlayer = data.player;
                    socket.dispatchEvent(new CustomEvent('roomJoined', { detail: { room: demoRoom, player: data.player } }));
                    break;
                    
                case 'toggleReady':
                    gameState.currentPlayer.isReady = !gameState.currentPlayer.isReady;
                    // NPCã‚‚è‡ªå‹•ã§æº–å‚™å®Œäº†
                    setTimeout(() => {
                        gameState.currentRoom.players.forEach(p => {
                            if (p.id.startsWith('demo')) p.isReady = true;
                        });
                        socket.dispatchEvent(new CustomEvent('roomUpdated', { detail: { room: gameState.currentRoom } }));
                    }, 1000);
                    break;
                    
                case 'startGame':
                    const gamePlayers = gameState.currentRoom.players.map((player, index) => ({
                        ...player,
                        hp: 10,
                        maxHp: 10,
                        hand: generateInitialHand(),
                        statusEffects: [],
                        isAlive: true,
                        possessedBy: null,
                        stunned: false
                    }));
                    
                    socket.dispatchEvent(new CustomEvent('gameStarted', { 
                        detail: { 
                            players: gamePlayers,
                            currentPlayerIndex: 0,
                            turnNumber: 1
                        } 
                    }));
                    break;
                    
                case 'playerAction':
                    processPlayerAction(data);
                    break;
            }
        }

        function generateInitialHand() {
            const hand = [];
            for (let i = 0; i < 5; i++) {
                const randomCard = CARD_DATABASE[Math.floor(Math.random() * CARD_DATABASE.length)];
                hand.push({...randomCard, instanceId: Math.random().toString(36).substr(2, 9)});
            }
            return hand;
        }

        function generateRoomId() {
            return Math.random().toString(36).substr(2, 6).toUpperCase();
        }

        function setupSocketListeners() {
            socket.on('connect', () => {
                console.log('ã‚µãƒ¼ãƒãƒ¼ã«æ¥ç¶šã•ã‚Œã¾ã—ãŸ');
                gameState.playerId = socket.id;
                updateConnectionStatus(true);
                document.getElementById('my-player-id').textContent = socket.id;
            });

            socket.on('disconnect', () => {
                console.log('ã‚µãƒ¼ãƒãƒ¼ã‹ã‚‰åˆ‡æ–­ã•ã‚Œã¾ã—ãŸ');
                updateConnectionStatus(false);
                showActionFeedback('ã‚µãƒ¼ãƒãƒ¼ã‹ã‚‰åˆ‡æ–­ã•ã‚Œã¾ã—ãŸ', 'error');
            });

            socket.on('roomsList', (rooms) => {
                updateRoomsList(rooms);
            });

            socket.on('roomCreated', (data) => {
                gameState.currentRoom = data.room;
                gameState.currentPlayer = data.player;
                showWaitingScreen();
                showActionFeedback('éƒ¨å±‹ãŒä½œæˆã•ã‚Œã¾ã—ãŸï¼', 'success');
            });

            socket.on('roomJoined', (data) => {
                gameState.currentRoom = data.room;
                gameState.currentPlayer = data.player;
                showWaitingScreen();
                showActionFeedback('éƒ¨å±‹ã«å‚åŠ ã—ã¾ã—ãŸï¼', 'success');
            });

            socket.on('roomUpdated', (data) => {
                gameState.currentRoom = data.room;
                updateWaitingRoom();
            });

            socket.on('gameStarted', (data) => {
                gameState.players = data.players;
                gameState.currentPlayerIndex = data.currentPlayerIndex;
                gameState.turnNumber = data.turnNumber;
                gameState.phase = 'battle';
                gameState.isMyTurn = data.currentPlayerIndex === gameState.currentPlayer.index;
                showGameScreen();
                startTurnTimer();
            });

            socket.on('turnChanged', (data) => {
                gameState.currentPlayerIndex = data.currentPlayerIndex;
                gameState.turnNumber = data.turnNumber;
                gameState.isMyTurn = gameState.players[data.currentPlayerIndex].id === gameState.playerId;
                updateGameDisplay();
                resetTurnTimer();
            });

            socket.on('actionPerformed', (data) => {
                applyGameAction(data);
                updateGameDisplay();
            });

            socket.on('gameEnded', (data) => {
                showGameEndScreen(data.rankings);
            });

            socket.on('error', (error) => {
                console.error('Socket error:', error);
                showActionFeedback(`ã‚¨ãƒ©ãƒ¼: ${error.message}`, 'error');
            });
        }

        // éƒ¨å±‹ç®¡ç†é–¢æ•°
        function createRoom() {
            const playerName = document.getElementById('player-name').value.trim() || 'ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼1';
            const roomName = document.getElementById('room-name').value.trim() || `${playerName}ã®éƒ¨å±‹`;
            const maxPlayers = parseInt(document.getElementById('max-players').value);

            const player = {
                id: gameState.playerId || generateRoomId(),
                name: playerName,
                isReady: false,
                isHost: true,
                index: 0
            };

            if (socket && socket.connected) {
                socket.emit('createRoom', {
                    roomName: roomName,
                    maxPlayers: maxPlayers,
                    player: player
                });
            } else {
                socket.emit('createRoom', {
                    roomName: roomName,
                    maxPlayers: maxPlayers,
                    player: player
                });
            }
        }

        function joinRoom(roomId) {
            const playerName = document.getElementById('player-name').value.trim() || 'ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼1';
            
            const player = {
                id: gameState.playerId || generateRoomId(),
                name: playerName,
                isReady: false,
                isHost: false
            };

            if (socket && socket.connected) {
                socket.emit('joinRoom', {
                    roomId: roomId,
                    player: player
                });
            } else {
                socket.emit('joinRoom', {
                    roomId: roomId,
                    player: player
                });
            }
        }

        function joinRoomById() {
            const roomId = document.getElementById('room-id-input').value.trim();
            if (!roomId) {
                showActionFeedback('éƒ¨å±‹IDã‚’å…¥åŠ›ã—ã¦ãã ã•ã„', 'error');
                return;
            }
            joinRoom(roomId);
        }

        function leaveRoom() {
            if (socket && socket.connected) {
                socket.emit('leaveRoom', {
                    roomId: gameState.currentRoom.id,
                    playerId: gameState.playerId
                });
            }
            
            gameState.currentRoom = null;
            gameState.currentPlayer = null;
            showRoomScreen();
            showActionFeedback('éƒ¨å±‹ã‚’å‡ºã¾ã—ãŸ', 'success');
        }

        function refreshRooms() {
            if (socket && socket.connected) {
                socket.emit('getRooms');
            } else {
                updateRoomsList([
                    { id: 'demo1', name: 'ãƒ‡ãƒ¢ãƒ«ãƒ¼ãƒ 1', players: 2, maxPlayers: 4 },
                    { id: 'demo2', name: 'ãƒ‡ãƒ¢ãƒ«ãƒ¼ãƒ 2', players: 1, maxPlayers: 3 },
                    { id: 'demo3', name: 'ãƒ‡ãƒ¢ãƒ«ãƒ¼ãƒ 3', players: 3, maxPlayers: 6 }
                ]);
            }
        }

        function toggleReady() {
            if (!gameState.currentPlayer) return;

            if (socket && socket.connected) {
                socket.emit('toggleReady', {
                    roomId: gameState.currentRoom.id,
                    playerId: gameState.playerId
                });
            } else {
                socket.emit('toggleReady', {
                    roomId: gameState.currentRoom.id,
                    playerId: gameState.currentPlayer.id
                });
            }
        }

        function startOnlineGame() {
            if (!gameState.currentPlayer.isHost) {
                showActionFeedback('ãƒ›ã‚¹ãƒˆã®ã¿ãŒã‚²ãƒ¼ãƒ ã‚’é–‹å§‹ã§ãã¾ã™', 'error');
                return;
            }

            if (socket && socket.connected) {
                socket.emit('startGame', {
                    roomId: gameState.currentRoom.id
                });
            } else {
                socket.emit('startGame', {
                    roomId: gameState.currentRoom.id
                });
            }
        }

        // ç”»é¢è¡¨ç¤ºé–¢æ•°
        function showRoomScreen() {
            document.getElementById('room-screen').style.display = 'block';
            document.getElementById('waiting-screen').style.display = 'none';
            document.getElementById('game-screen').style.display = 'none';
            refreshRooms();
        }

        function showWaitingScreen() {
            document.getElementById('room-screen').style.display = 'none';
            document.getElementById('waiting-screen').style.display = 'block';
            document.getElementById('game-screen').style.display = 'none';
            updateWaitingRoom();
        }

        function showGameScreen() {
            document.getElementById('room-screen').style.display = 'none';
            document.getElementById('waiting-screen').style.display = 'none';
            document.getElementById('game-screen').style.display = 'block';
            updateGameDisplay();
            addToLog('ã‚ªãƒ³ãƒ©ã‚¤ãƒ³ã‚²ãƒ¼ãƒ ãŒé–‹å§‹ã•ã‚Œã¾ã—ãŸï¼');
        }

        function updateRoomsList(rooms) {
            const container = document.getElementById('available-rooms');
            container.innerHTML = '';

            if (rooms.length === 0) {
                container.innerHTML = '<p>ç¾åœ¨åˆ©ç”¨å¯èƒ½ãªéƒ¨å±‹ã¯ã‚ã‚Šã¾ã›ã‚“</p>';
                return;
            }

            rooms.forEach(room => {
                const roomDiv = document.createElement('div');
                roomDiv.className = 'room-item';
                
                const isFull = room.players >= room.maxPlayers;
                const joinButton = isFull ? 
                    '<button class="btn btn-secondary" disabled>æº€å®¤</button>' :
                    `<button class="btn btn-secondary" onclick="joinRoom('${room.id}')">å‚åŠ </button>`;
                
                roomDiv.innerHTML = `
                    <div class="room-info">
                        <div class="room-name">${room.name}</div>
                        <div class="room-players">${room.players}/${room.maxPlayers}äºº</div>
                    </div>
                    ${joinButton}
                `;
                container.appendChild(roomDiv);
            });
        }

        function updateWaitingRoom() {
            const room = gameState.currentRoom;
            if (!room) return;

            document.getElementById('room-title').textContent = room.name;
            document.getElementById('room-code').textContent = `éƒ¨å±‹ID: ${room.id}`;

            const playersContainer = document.getElementById('players-in-room');
            playersContainer.innerHTML = '';

            room.players.forEach(player => {
                const playerDiv = document.createElement('div');
                playerDiv.className = 'player-item';
                
                const readyStatus = player.isReady ? 
                    '<span class="player-ready">âœ“ æº–å‚™å®Œäº†</span>' : 
                    '<span class="player-waiting">â³ å¾…æ©Ÿä¸­</span>';
                
                const hostBadge = player.isHost ? ' ğŸ‘‘' : '';
                const meBadge = player.id === gameState.playerId ? ' (ã‚ãªãŸ)' : '';

                playerDiv.innerHTML = `
                    <div>${player.name}${hostBadge}${meBadge}</div>
                    <div>${readyStatus}</div>
                `;
                playersContainer.appendChild(playerDiv);
            });

            // æº–å‚™ãƒœã‚¿ãƒ³ã®çŠ¶æ…‹æ›´æ–°
            const readyButton = document.getElementById('ready-toggle');
            if (gameState.currentPlayer.isReady) {
                readyButton.textContent = 'æº–å‚™è§£é™¤';
                readyButton.className = 'btn btn-secondary';
            } else {
                readyButton.textContent = 'æº–å‚™å®Œäº†';
                readyButton.className = 'btn btn-success';
            }

            // å…¨å“¡æº–å‚™å®Œäº†ãƒã‚§ãƒƒã‚¯ï¼ˆãƒ›ã‚¹ãƒˆã®ã¿ï¼‰
            if (gameState.currentPlayer.isHost) {
                const allReady = room.players.every(p => p.isReady);
                const minPlayers = room.players.length >= 2;
                
                if (allReady && minPlayers) {
                    document.getElementById('start-game-section').style.display = 'block';
                } else {
                    document.getElementById('start-game-section').style.display = 'none';
                }
            }
        }

        // ã‚²ãƒ¼ãƒ é–¢æ•°
        function updateGameDisplay() {
            updateGameStatus();
            updatePlayersGrid();
            updatePlayerHand();
            updateActionButtons();
        }

        function updateGameStatus() {
            document.getElementById('current-turn').textContent = gameState.turnNumber;
            const currentPlayer = gameState.players[gameState.currentPlayerIndex];
            document.getElementById('current-player-name').textContent = currentPlayer.name;
            document.getElementById('current-room-name').textContent = gameState.currentRoom.name;
        }

        function updatePlayersGrid() {
            const grid = document.getElementById('players-grid');
            grid.innerHTML = '';
            
            gameState.players.forEach((player, index) => {
                const playerCard = document.createElement('div');
                playerCard.className = `player-card ${index === gameState.currentPlayerIndex ? 'current-turn' : ''} ${!player.isAlive ? 'dead' : ''}`;
                
                const statusEffectsHtml = player.statusEffects.map(effect => 
                    `<span class="status-effect ${effect.element}">${ELEMENT_NAMES[effect.element]}(${effect.duration})</span>`
                ).join('');

                const isCurrentUser = player.id === gameState.playerId;
                const playerLabel = isCurrentUser ? `${player.name} (ã‚ãªãŸ)` : player.name;

                playerCard.innerHTML = `
                    <div class="player-name">${playerLabel}</div>
                    <div class="player-hp">HP: ${player.hp}/${player.maxHp}</div>
                    <div class="player-status">æ‰‹æœ­: ${player.hand.length}æš</div>
                    <div class="status-effects">${statusEffectsHtml}</div>
                `;
                
                grid.appendChild(playerCard);
            });
        }

        function updatePlayerHand() {
            const currentUser = gameState.players.find(p => p.id === gameState.playerId);
            if (!currentUser) return;

            const container = document.getElementById('hand-cards');
            container.innerHTML = '';
            
            document.getElementById('hand-count').textContent = currentUser.hand.length;

            currentUser.hand.forEach(card => {
                const cardElement = createCardElement(card, true);
                if (gameState.selectedCard && gameState.selectedCard.instanceId === card.instanceId) {
                    cardElement.classList.add('selected');
                }
                container.appendChild(cardElement);
            });
        }

        function createCardElement(card, clickable = false) {
            const cardDiv = document.createElement('div');
            cardDiv.className = `card ${card.element}`;
            if (clickable) {
                cardDiv.onclick = () => selectCard(card);
            }
            
            cardDiv.innerHTML = `
                <div class="card-name">${card.name}</div>
                <div class="card-description">${card.description}</div>
                <div class="card-damage">ãƒ€ãƒ¡ãƒ¼ã‚¸: ${card.damage}</div>
                <div class="card-element">${ELEMENT_NAMES[card.element]}</div>
            `;
            
            return cardDiv;
        }

        function updateActionButtons() {
            const isMyTurn = gameState.isMyTurn;
            const currentUser = gameState.players.find(p => p.id === gameState.playerId);
            const isAlive = currentUser && currentUser.isAlive;
            
            document.getElementById('use-card-btn').disabled = !isMyTurn || !isAlive;
            document.getElementById('draw-card-btn').disabled = !isMyTurn || !isAlive;
        }

        function selectCard(card) {
            if (!gameState.isMyTurn) {
                showActionFeedback('ã‚ãªãŸã®ã‚¿ãƒ¼ãƒ³ã§ã¯ã‚ã‚Šã¾ã›ã‚“', 'error');
                return;
            }
            
            gameState.selectedCard = card;
            updatePlayerHand();
        }

        function selectAction(action) {
            if (!gameState.isMyTurn) {
                showActionFeedback('ã‚ãªãŸã®ã‚¿ãƒ¼ãƒ³ã§ã¯ã‚ã‚Šã¾ã›ã‚“', 'error');
                return;
            }
            
            if (action === 'useCard') {
                if (!gameState.selectedCard) {
                    showActionFeedback('ã‚«ãƒ¼ãƒ‰ã‚’é¸æŠã—ã¦ãã ã•ã„ï¼', 'error');
                    return;
                }
                showTargetSelection();
            } else if (action === 'drawCard') {
                performAction({ type: 'drawCard' });
            }
        }

        function showTargetSelection() {
            document.getElementById('target-selection').style.display = 'block';
            const container = document.getElementById('target-players');
            container.innerHTML = '';
            
            gameState.players.forEach((player, index) => {
                if (player.isAlive) {
                    const button = document.createElement('button');
                    button.className = 'target-player';
                    button.textContent = `${player.name} (HP: ${player.hp})`;
                    button.onclick = () => selectTarget(index);
                    container.appendChild(button);
                }
            });
            
            document.getElementById('confirm-action-btn').style.display = 'block';
        }

        function selectTarget(playerIndex) {
            gameState.selectedTarget = playerIndex;
            
            // ãƒã‚¤ãƒ©ã‚¤ãƒˆæ›´æ–°
            document.querySelectorAll('.target-player').forEach(btn => {
                btn.classList.remove('selected');
            });
            event.target.classList.add('selected');
        }

        function confirmAction() {
            if (gameState.selectedCard && gameState.selectedTarget !== null) {
                performAction({
                    type: 'useCard',
                    card: gameState.selectedCard,
                    targetIndex: gameState.selectedTarget
                });
                
                // UI ãƒªã‚»ãƒƒãƒˆ
                gameState.selectedCard = null;
                gameState.selectedTarget = null;
                document.getElementById('target-selection').style.display = 'none';
                document.getElementById('confirm-action-btn').style.display = 'none';
            }
        }

        function performAction(actionData) {
            if (socket && socket.connected) {
                socket.emit('playerAction', {
                    roomId: gameState.currentRoom.id,
                    playerId: gameState.playerId,
                    action: actionData
                });
            } else {
                socket.emit('playerAction', {
                    roomId: gameState.currentRoom.id,
                    playerId: gameState.playerId || gameState.currentPlayer.id,
                    action: actionData
                });
            }
        }

        function processPlayerAction(data) {
            // ãƒ‡ãƒ¢ãƒ¢ãƒ¼ãƒ‰ç”¨ã®ã‚¢ã‚¯ã‚·ãƒ§ãƒ³å‡¦ç†
            setTimeout(() => {
                socket.dispatchEvent(new CustomEvent('actionPerformed', { 
                    detail: data 
                }));
                
                // æ¬¡ã®ã‚¿ãƒ¼ãƒ³ã«é€²ã‚€
                setTimeout(() => {
                    const nextPlayerIndex = (gameState.currentPlayerIndex + 1) % gameState.players.length;
                    const nextTurnNumber = nextPlayerIndex === 0 ? gameState.turnNumber + 1 : gameState.turnNumber;
                    
                    socket.dispatchEvent(new CustomEvent('turnChanged', { 
                        detail: { 
                            currentPlayerIndex: nextPlayerIndex,
                            turnNumber: nextTurnNumber
                        } 
                    }));
                }, 1500);
            }, 500);
        }

        function applyGameAction(data) {
            const { action, playerId } = data;
            const player = gameState.players.find(p => p.id === playerId);
            
            if (!player) return;
            
            if (action.type === 'drawCard') {
                const randomCard = CARD_DATABASE[Math.floor(Math.random() * CARD_DATABASE.length)];
                player.hand.push({...randomCard, instanceId: Math.random().toString(36).substr(2, 9)});
                addToLog(`${player.name}ãŒã‚«ãƒ¼ãƒ‰ã‚’1æšå¼•ãã¾ã—ãŸ`);
                
            } else if (action.type === 'useCard') {
                const target = gameState.players[action.targetIndex];
                
                // ã‚«ãƒ¼ãƒ‰ã‚’æ‰‹æœ­ã‹ã‚‰å‰Šé™¤
                player.hand = player.hand.filter(c => c.instanceId !== action.card.instanceId);
                
                // ãƒ€ãƒ¡ãƒ¼ã‚¸é©ç”¨
                if (action.card.damage > 0) {
                    target.hp = Math.max(0, target.hp - action.card.damage);
                    addToLog(`${player.name}ãŒ${target.name}ã«${action.card.name}ã‚’ä½¿ç”¨ï¼${action.card.damage}ãƒ€ãƒ¡ãƒ¼ã‚¸`);
                }
                
                // ç‰¹æ®ŠåŠ¹æœå‡¦ç†
                processCardEffects(action.card, target, player);
                
                // HP0ãƒã‚§ãƒƒã‚¯
                if (target.hp <= 0 && target.isAlive) {
                    target.isAlive = false;
                    addToLog(`${target.name}ãŒå€’ã‚Œã¾ã—ãŸï¼`);
                    
                    // ã‚²ãƒ¼ãƒ çµ‚äº†ãƒã‚§ãƒƒã‚¯
                    const alivePlayers = gameState.players.filter(p => p.isAlive);
                    if (alivePlayers.length <= 1) {
                        setTimeout(() => {
                            socket.dispatchEvent(new CustomEvent('gameEnded', {
                                detail: { rankings: createRankings() }
                            }));
                        }, 2000);
                    }
                }
            }
        }

        function processCardEffects(card, target, attacker) {
            // å±æ€§çŠ¶æ…‹ä»˜ä¸
            if (card.element) {
                applyStatusEffect(target, card.element);
            }
            
            // ã‚«ãƒ¼ãƒ‰å›ºæœ‰åŠ¹æœ
            switch (card.name) {
                case 'æ°´ã®ç™’ã—':
                    target.hp = Math.min(target.maxHp, target.hp + 2);
                    addToLog(`${target.name}ã®HPãŒ2å›å¾©ï¼`);
                    break;
                case 'ç–¾é¢¨':
                    const randomCard = CARD_DATABASE[Math.floor(Math.random() * CARD_DATABASE.length)];
                    attacker.hand.push({...randomCard, instanceId: Math.random().toString(36).substr(2, 9)});
                    addToLog(`${attacker.name}ãŒè¿½åŠ ã§ã‚«ãƒ¼ãƒ‰ã‚’1æšå¼•ã„ãŸï¼`);
                    break;
            }
        }

        function applyStatusEffect(player, element) {
            // æ—¢å­˜ã®åŒã˜å±æ€§åŠ¹æœã‚’é™¤å»
            player.statusEffects = player.statusEffects.filter(effect => effect.element !== element);
            
            // æ–°ã—ã„åŠ¹æœã‚’è¿½åŠ 
            player.statusEffects.push({
                element: element,
                duration: 2
            });
            
            // æœ€å¤§2ã¤ã¾ã§ã®åˆ¶é™
            if (player.statusEffects.length > 2) {
                player.statusEffects.shift();
            }
            
            // å±æ€§ç›¸æ€§ãƒã‚§ãƒƒã‚¯
            checkElementalReactions(player);
        }

        function checkElementalReactions(player) {
            if (player.statusEffects.length < 2) return;
            
            const elements = player.statusEffects.map(effect => effect.element);
            const reactionKey = elements.join(',');
            const reverseKey = [...elements].reverse().join(',');
            
            const reaction = ELEMENT_REACTIONS[reactionKey] || ELEMENT_REACTIONS[reverseKey];
            
            if (reaction) {
                addToLog(`${player.name}ã«${reaction.name}ãŒç™ºç”Ÿï¼`);
                
                // å±æ€§çŠ¶æ…‹ã‚’ã‚¯ãƒªã‚¢
                player.statusEffects = [];
                
                // åå¿œåŠ¹æœã‚’é©ç”¨
                applyReactionEffect(player, reaction.effect);
            }
        }

        function applyReactionEffect(player, effect) {
            switch (effect) {
                case 'steam':
                case 'burn':
                    player.hp = Math.max(0, player.hp - 1);
                    if (player.hand.length > 0) {
                        const randomIndex = Math.floor(Math.random() * player.hand.length);
                        player.hand.splice(randomIndex, 1);
                        addToLog(`${player.name}ã®æ‰‹æœ­ãŒ1æšæ¶ˆæ»…ï¼`);
                    }
                    break;
                case 'shock':
                case 'melt':
                case 'dissolve':
                    player.hp = Math.max(0, player.hp - 1);
                    player.stunned = true;
                    addToLog(`${player.name}ã¯æ¬¡ã®ã‚¿ãƒ¼ãƒ³ã‚«ãƒ¼ãƒ‰ã‚’ä½¿ãˆã¾ã›ã‚“ï¼`);
                    break;
                case 'overreaction':
                    player.hp = Math.max(0, player.hp - 2);
                    addToLog(`${player.name}ã¯éå‰°åå¿œã«ã‚ˆã‚Š2ãƒ€ãƒ¡ãƒ¼ã‚¸ï¼`);
                    break;
                case 'erosion':
                    for (let i = 0; i < 3 && player.hand.length > 0; i++) {
                        const randomIndex = Math.floor(Math.random() * player.hand.length);
                        player.hand.splice(randomIndex, 1);
                    }
                    addToLog(`${player.name}ã®æ‰‹æœ­ãŒ3æšæ¶ˆæ»…ï¼`);
                    break;
            }
        }

        function createRankings() {
            return [...gameState.players].sort((a, b) => {
                if (a.isAlive && !b.isAlive) return -1;
                if (!a.isAlive && b.isAlive) return 1;
                return b.hp - a.hp;
            });
        }

        function showGameEndScreen(rankings) {
            document.getElementById('game-over-screen').style.display = 'block';
            
            const rankingDiv = document.getElementById('final-ranking');
            rankingDiv.innerHTML = rankings.map((player, index) => 
                `<div><strong>${index + 1}ä½:</strong> ${player.name} (HP: ${player.hp}/${player.maxHp}) ${player.isAlive ? 'ğŸ‰ç”Ÿå­˜' : 'ğŸ’€æ­»äº¡'}</div>`
            ).join('');
            
            addToLog('ã‚²ãƒ¼ãƒ çµ‚äº†ï¼');
        }

        // ã‚¿ãƒ¼ãƒ³ã‚¿ã‚¤ãƒãƒ¼æ©Ÿèƒ½
        function startTurnTimer() {
            resetTurnTimer();
        }

        function resetTurnTimer() {
            clearInterval(gameState.turnTimer);
            gameState.turnTimeLeft = 30;
            
            if (gameState.isMyTurn) {
                document.getElementById('turn-timer').style.display = 'block';
                updateTimerDisplay();
                
                gameState.turnTimer = setInterval(() => {
                    gameState.turnTimeLeft--;
                    updateTimerDisplay();
                    
                    if (gameState.turnTimeLeft <= 0) {
                        // æ™‚é–“åˆ‡ã‚Œã§è‡ªå‹•çš„ã«ã‚«ãƒ¼ãƒ‰ãƒ‰ãƒ­ãƒ¼
                        performAction({ type: 'drawCard' });
                    }
                }, 1000);
            } else {
                document.getElementById('turn-timer').style.display = 'none';
            }
        }

        function updateTimerDisplay() {
            document.getElementById('timer-seconds').textContent = gameState.turnTimeLeft;
        }

        // ãƒ¦ãƒ¼ãƒ†ã‚£ãƒªãƒ†ã‚£é–¢æ•°
        function updateConnectionStatus(connected) {
            const statusEl = document.getElementById('connection-status');
            const textEl = document.getElementById('connection-text');
            
            if (connected) {
                statusEl.className = 'connection-status connected';
                textEl.textContent = 'ğŸŸ¢ ã‚ªãƒ³ãƒ©ã‚¤ãƒ³';
            } else {
                statusEl.className = 'connection-status disconnected';
                textEl.textContent = 'ğŸ”´ ã‚ªãƒ•ãƒ©ã‚¤ãƒ³';
            }
        }

        function showActionFeedback(message, type = 'success') {
            const feedbackDiv = document.getElementById('action-feedback');
            const className = type === 'error' ? 'action-feedback error-feedback' : 'action-feedback';
            feedbackDiv.innerHTML = `<div class="${className}">${message}</div>`;
            
            setTimeout(() => {
                feedbackDiv.innerHTML = '';
            }, 3000);
        }

        function addToLog(message) {
            const log = document.getElementById('game-log');
            const entry = document.createElement('div');
            entry.className = 'log-entry';
            entry.textContent = `[${new Date().toLocaleTimeString()}] ${message}`;
            log.appendChild(entry);
            log.scrollTop = log.scrollHeight;
        }

        function backToRooms() {
            clearInterval(gameState.turnTimer);
            gameState = {
                phase: 'rooms',
                currentRoom: null,
                currentPlayer: null,
                players: [],
                currentPlayerIndex: 0,
                turnNumber: 1,
                selectedCard: null,
                selectedTarget: null,
                isMyTurn: false,
                turnTimeLeft: 30,
                turnTimer: null,
                playerId: gameState.playerId
            };
            showRoomScreen();
        }

        // åˆæœŸåŒ–
        window.onload = function() {
            initializeSocket();
            showRoomScreen();
        };
  </script>
</body>
</html>
