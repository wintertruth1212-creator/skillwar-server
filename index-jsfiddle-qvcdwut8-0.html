<!DOCTYPE html>
<html>

<html>
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>Skill War Online</title>

  <style>
    * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Arial', sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            color: #333;
        }

        .container {
            max-width: 1200px;
            margin: 0 auto;
            padding: 20px;
        }

        .game-header {
            text-align: center;
            margin-bottom: 30px;
        }

        .game-title {
            font-size: 3em;
            color: #fff;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.3);
            margin-bottom: 10px;
        }

        .game-status {
            background: rgba(255,255,255,0.9);
            padding: 15px;
            border-radius: 10px;
            margin-bottom: 20px;
            box-shadow: 0 4px 6px rgba(0,0,0,0.1);
        }

        .players-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
            gap: 20px;
            margin-bottom: 30px;
        }

        .player-card {
            background: rgba(255,255,255,0.95);
            border-radius: 15px;
            padding: 20px;
            box-shadow: 0 8px 16px rgba(0,0,0,0.1);
            transition: transform 0.3s ease;
        }

        .player-card:hover {
            transform: translateY(-5px);
        }

        .player-card.current-turn {
            border: 3px solid #ff6b6b;
            box-shadow: 0 0 20px rgba(255,107,107,0.5);
            animation: pulse 2s infinite;
        }

        @keyframes pulse {
            0% { box-shadow: 0 0 20px rgba(255,107,107,0.5); }
            50% { box-shadow: 0 0 30px rgba(255,107,107,0.8); }
            100% { box-shadow: 0 0 20px rgba(255,107,107,0.5); }
        }

        .player-card.dead {
            background: rgba(0,0,0,0.8);
            color: #fff;
        }

        .player-name {
            font-size: 1.2em;
            font-weight: bold;
            margin-bottom: 10px;
            color: #4a5568;
        }

        .player-hp {
            font-size: 1.5em;
            color: #e53e3e;
            margin-bottom: 10px;
        }

        .player-status {
            margin: 10px 0;
        }

        .status-effects {
            display: flex;
            gap: 5px;
            margin-top: 10px;
            flex-wrap: wrap;
        }

        .status-effect {
            padding: 4px 8px;
            border-radius: 15px;
            font-size: 0.8em;
            color: #fff;
        }

        .fire { background-color: #ff4444; }
        .water { background-color: #4444ff; }
        .wind { background-color: #44ff44; }
        .earth { background-color: #8b4513; }
        .thunder { background-color: #ffff00; color: #000; }
        .ice { background-color: #87ceeb; }

        .hand-cards {
            background: rgba(255,255,255,0.9);
            padding: 20px;
            border-radius: 15px;
            margin-bottom: 20px;
        }

        .cards-container {
            display: flex;
            gap: 10px;
            overflow-x: auto;
            padding: 10px 0;
        }

        .card {
            min-width: 150px;
            background: linear-gradient(135deg, #f093fb 0%, #f5576c 100%);
            border-radius: 10px;
            padding: 15px;
            color: #fff;
            cursor: pointer;
            transition: transform 0.3s ease;
            box-shadow: 0 4px 8px rgba(0,0,0,0.2);
        }

        .card:hover {
            transform: scale(1.05);
        }

        .card.selected {
            border: 3px solid #ffd700;
            transform: scale(1.1);
        }

        .card-name {
            font-weight: bold;
            margin-bottom: 5px;
        }

        .card-description {
            font-size: 0.8em;
            margin-bottom: 10px;
        }

        .card-damage {
            color: #ffeb3b;
            font-weight: bold;
        }

        .actions-panel {
            background: rgba(255,255,255,0.9);
            padding: 20px;
            border-radius: 15px;
            text-align: center;
        }

        .action-buttons {
            display: flex;
            gap: 15px;
            justify-content: center;
            margin-bottom: 20px;
        }

        .btn {
            padding: 12px 24px;
            border: none;
            border-radius: 25px;
            cursor: pointer;
            font-size: 1em;
            font-weight: bold;
            transition: all 0.3s ease;
            box-shadow: 0 4px 8px rgba(0,0,0,0.2);
        }

        .btn-primary {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
        }

        .btn-secondary {
            background: linear-gradient(135deg, #f093fb 0%, #f5576c 100%);
            color: white;
        }

        .btn-success {
            background: linear-gradient(135deg, #4facfe 0%, #00f2fe 100%);
            color: white;
        }

        .btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 12px rgba(0,0,0,0.3);
        }

        .btn:disabled {
            opacity: 0.5;
            cursor: not-allowed;
            transform: none;
        }

        .target-selection {
            margin: 20px 0;
        }

        .target-players {
            display: flex;
            gap: 10px;
            justify-content: center;
            flex-wrap: wrap;
        }

        .target-player {
            padding: 10px 20px;
            background: #4a5568;
            color: white;
            border: none;
            border-radius: 20px;
            cursor: pointer;
            transition: all 0.3s ease;
        }

        .target-player:hover {
            background: #2d3748;
            transform: scale(1.05);
        }

        .target-player.selected {
            background: #e53e3e;
        }

        .room-setup {
            background: rgba(255,255,255,0.95);
            padding: 30px;
            border-radius: 15px;
            text-align: center;
            margin-bottom: 20px;
        }

        .room-input {
            margin: 10px;
            padding: 10px;
            border: 2px solid #ddd;
            border-radius: 5px;
            font-size: 1em;
            width: 200px;
        }

        .room-list {
            background: rgba(255,255,255,0.9);
            padding: 20px;
            border-radius: 15px;
            margin-bottom: 20px;
        }

        .room-item {
            background: rgba(106, 90, 205, 0.1);
            padding: 15px;
            margin: 10px 0;
            border-radius: 10px;
            border-left: 4px solid #6a5acd;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .room-info {
            flex: 1;
        }

        .room-name {
            font-weight: bold;
            color: #4a5568;
        }

        .room-players {
            color: #666;
            font-size: 0.9em;
        }

        .waiting-room {
            background: rgba(255,255,255,0.95);
            padding: 30px;
            border-radius: 15px;
            text-align: center;
        }

        .players-list {
            background: rgba(248, 249, 250, 0.8);
            padding: 20px;
            border-radius: 10px;
            margin: 20px 0;
        }

        .player-item {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 10px;
            margin: 5px 0;
            background: rgba(255,255,255,0.8);
            border-radius: 8px;
        }

        .player-ready {
            color: #48bb78;
            font-weight: bold;
        }

        .player-waiting {
            color: #ed8936;
        }

        .connection-status {
            position: fixed;
            top: 20px;
            right: 20px;
            padding: 10px 15px;
            border-radius: 20px;
            font-weight: bold;
            z-index: 1000;
        }

        .connected {
            background: #48bb78;
            color: white;
        }

        .disconnected {
            background: #e53e3e;
            color: white;
        }

        .turn-timer {
            background: rgba(255,107,107,0.9);
            color: white;
            padding: 15px;
            border-radius: 10px;
            text-align: center;
            font-size: 1.2em;
            font-weight: bold;
            margin-bottom: 20px;
        }

        .game-log {
            background: rgba(0,0,0,0.8);
            color: #fff;
            padding: 15px;
            border-radius: 10px;
            max-height: 200px;
            overflow-y: auto;
            margin-bottom: 20px;
        }

        .log-entry {
            margin: 5px 0;
            padding: 3px 0;
            border-bottom: 1px solid rgba(255,255,255,0.2);
        }

        .ghost-panel {
            background: rgba(0,0,0,0.9);
            color: #fff;
            padding: 20px;
            border-radius: 15px;
            text-align: center;
            margin-bottom: 20px;
        }

        .ghost-title {
            font-size: 1.5em;
            margin-bottom: 10px;
            color: #ff6b6b;
        }

        .possess-targets {
            display: flex;
            gap: 10px;
            justify-content: center;
            flex-wrap: wrap;
            margin-top: 15px;
        }

        .action-feedback {
            background: rgba(72, 187, 120, 0.9);
            color: white;
            padding: 10px;
            border-radius: 8px;
            margin: 10px 0;
            text-align: center;
            animation: fadeInOut 3s ease-in-out;
        }

        .error-feedback {
            background: rgba(229, 62, 62, 0.9);
        }

        @keyframes fadeInOut {
            0% { opacity: 0; transform: translateY(-10px); }
            20% { opacity: 1; transform: translateY(0); }
            80% { opacity: 1; transform: translateY(0); }
            100% { opacity: 0; transform: translateY(-10px); }
        }

        .server-info {
            background: rgba(255,255,255,0.9);
            padding: 15px;
            border-radius: 10px;
            margin-bottom: 20px;
            text-align: center;
            font-size: 0.9em;
            color: #666;
        }
  </style>

  
</head>
<body>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/socket.io/4.7.2/socket.io.js"></script>
    


    <div class="connection-status" id="connection-status">
        <span id="connection-text">接続中...</span>
    </div>

    <div class="container">
        <div class="game-header">
            <h1 class="game-title">⚔️ Skill War Online ⚔️</h1>
        </div>

        <div class="server-info">
            <p><strong>サーバー接続:</strong> <span id="server-url">wss://skillwar-server.herokuapp.com</span></p>
            <p>リアルタイム通信でマルチプレイヤーゲームを楽しもう！</p>
        </div>

        <!-- 部屋選択/作成画面 -->
        <div id="room-screen" class="room-setup">
            <h2>🌐 オンラインマッチング</h2>
            
            <div style="margin: 30px 0;">
                <h3>新しい部屋を作成</h3>
                <input type="text" id="player-name" class="room-input" placeholder="プレイヤー名" value="プレイヤー1">
                <input type="text" id="room-name" class="room-input" placeholder="部屋名" value="">
                <br>
                <label>最大人数：</label>
                <select id="max-players" class="room-input">
                    <option value="2">2人</option>
                    <option value="3">3人</option>
                    <option value="4" selected>4人</option>
                    <option value="5">5人</option>
                    <option value="6">6人</option>
                </select>
                <br>
                <button onclick="createRoom()" class="btn btn-primary">部屋作成</button>
            </div>

            <div class="room-list">
                <h3>利用可能な部屋</h3>
                <div id="available-rooms">
                    <p>部屋を検索中...</p>
                </div>
                <button onclick="refreshRooms()" class="btn btn-secondary">更新</button>
            </div>

            <div style="margin-top: 20px;">
                <h3>部屋IDで参加</h3>
                <input type="text" id="room-id-input" class="room-input" placeholder="部屋ID">
                <button onclick="joinRoomById()" class="btn btn-secondary">参加</button>
            </div>
        </div>

        <!-- 待機室画面 -->
        <div id="waiting-screen" style="display: none;" class="waiting-room">
            <h2 id="room-title">部屋名</h2>
            <div id="room-code" style="font-size: 1.2em; margin: 10px 0; color: #666;"></div>
            
            <div class="players-list">
                <h3>参加プレイヤー</h3>
                <div id="players-in-room"></div>
            </div>

            <div style="margin: 20px 0;">
                <button id="ready-toggle" onclick="toggleReady()" class="btn btn-success">準備完了</button>
                <button onclick="leaveRoom()" class="btn btn-secondary">部屋を出る</button>
            </div>

            <div id="start-game-section" style="display: none;">
                <button onclick="startOnlineGame()" class="btn btn-primary">🚀 ゲーム開始！</button>
            </div>
        </div>

        <!-- ゲーム画面 -->
        <div id="game-screen" style="display: none;">
            <div id="turn-timer" class="turn-timer" style="display: none;">
                ⏰ 残り時間: <span id="timer-seconds">30</span>秒
            </div>

            <div class="game-status">
                <div><strong>ターン:</strong> <span id="current-turn">1</span></div>
                <div><strong>現在のプレイヤー:</strong> <span id="current-player-name">-</span></div>
                <div><strong>部屋:</strong> <span id="current-room-name">-</span></div>
                <div><strong>プレイヤーID:</strong> <span id="my-player-id">-</span></div>
            </div>

            <div class="game-log" id="game-log">
                <div class="log-entry">ゲームが開始されました！</div>
            </div>

            <div class="players-grid" id="players-grid"></div>

            <div id="ghost-panel" class="ghost-panel" style="display: none;">
                <div class="ghost-title">👻 あなたは亡霊になりました 👻</div>
                <div>属性: <span id="ghost-element"></span></div>
                <div>生きているプレイヤーに取り憑くことができます</div>
                <div class="possess-targets" id="possess-targets"></div>
            </div>

            <div id="player-hand" class="hand-cards">
                <h3>手札 (<span id="hand-count">0</span>枚)</h3>
                <div class="cards-container" id="hand-cards"></div>
            </div>

            <div class="actions-panel">
                <div id="action-feedback"></div>
                
                <div class="action-buttons">
                    <button id="use-card-btn" class="btn btn-primary" onclick="selectAction('useCard')">カードを使う</button>
                    <button id="draw-card-btn" class="btn btn-secondary" onclick="selectAction('drawCard')">カードを引く</button>
                </div>

                <div id="target-selection" class="target-selection" style="display: none;">
                    <h4>ターゲットを選択してください：</h4>
                    <div class="target-players" id="target-players"></div>
                </div>

                <button id="confirm-action-btn" class="btn btn-success" onclick="confirmAction()" style="display: none;">アクション実行</button>
            </div>

            <div id="game-over-screen" style="display: none;" class="room-setup">
                <h2>🏆 ゲーム終了 🏆</h2>
                <div id="final-ranking"></div>
                <button onclick="backToRooms()" class="btn btn-primary">部屋一覧に戻る</button>
            </div>
        </div>
    </div>

  <script>
    // グローバル変数
        let socket = null;
        let gameState = {
            phase: 'rooms',
            currentRoom: null,
            currentPlayer: null,
            players: [],
            currentPlayerIndex: 0,
            turnNumber: 1,
            selectedCard: null,
            selectedTarget: null,
            isMyTurn: false,
            turnTimeLeft: 30,
            turnTimer: null,
            playerId: null
        };

        // 属性定数
        const ELEMENTS = {
            FIRE: 'fire',
            WATER: 'water',
            WIND: 'wind',
            EARTH: 'earth',
            THUNDER: 'thunder',
            ICE: 'ice'
        };

        const ELEMENT_NAMES = {
            [ELEMENTS.FIRE]: '炎',
            [ELEMENTS.WATER]: '水',
            [ELEMENTS.WIND]: '風',
            [ELEMENTS.EARTH]: '土',
            [ELEMENTS.THUNDER]: '雷',
            [ELEMENTS.ICE]: '氷'
        };

        // 属性相性システム
        const ELEMENT_REACTIONS = {
            [`${ELEMENTS.FIRE},${ELEMENTS.WATER}`]: { name: '蒸発', effect: 'steam' },
            [`${ELEMENTS.WATER},${ELEMENTS.FIRE}`]: { name: '蒸発', effect: 'steam' },
            [`${ELEMENTS.THUNDER},${ELEMENTS.WATER}`]: { name: '感電', effect: 'shock' },
            [`${ELEMENTS.WATER},${ELEMENTS.THUNDER}`]: { name: '感電', effect: 'shock' },
            [`${ELEMENTS.FIRE},${ELEMENTS.WIND}`]: { name: '燃焼', effect: 'burn' },
            [`${ELEMENTS.WIND},${ELEMENTS.FIRE}`]: { name: '燃焼', effect: 'burn' },
            [`${ELEMENTS.THUNDER},${ELEMENTS.FIRE}`]: { name: '過剰反応', effect: 'overreaction' },
            [`${ELEMENTS.FIRE},${ELEMENTS.THUNDER}`]: { name: '過剰反応', effect: 'overreaction' },
            [`${ELEMENTS.ICE},${ELEMENTS.FIRE}`]: { name: '溶解', effect: 'melt' },
            [`${ELEMENTS.FIRE},${ELEMENTS.ICE}`]: { name: '溶解', effect: 'melt' },
            [`${ELEMENTS.WATER},${ELEMENTS.EARTH}`]: { name: '溶解', effect: 'dissolve' },
            [`${ELEMENTS.EARTH},${ELEMENTS.WATER}`]: { name: '溶解', effect: 'dissolve' },
            [`${ELEMENTS.EARTH},${ELEMENTS.WIND}`]: { name: '風化', effect: 'erosion' },
            [`${ELEMENTS.WIND},${ELEMENTS.EARTH}`]: { name: '風化', effect: 'erosion' }
        };

        // カードデータベース
        const CARD_DATABASE = [
            // 炎属性カード
            { id: 1, name: '火の玉', element: ELEMENTS.FIRE, damage: 2, description: '基本的な炎攻撃' },
            { id: 2, name: '業火', element: ELEMENTS.FIRE, damage: 3, description: '強力な炎攻撃' },
            { id: 3, name: '火炎放射', element: ELEMENTS.FIRE, damage: 4, description: '範囲攻撃' },
            { id: 4, name: '爆炎', element: ELEMENTS.FIRE, damage: 5, description: '最強の炎攻撃' },
            { id: 5, name: '炎の壁', element: ELEMENTS.FIRE, damage: 1, description: '防御効果付き' },
            
            // 水属性カード
            { id: 6, name: '水流', element: ELEMENTS.WATER, damage: 2, description: '基本的な水攻撃' },
            { id: 7, name: '高圧放水', element: ELEMENTS.WATER, damage: 3, description: '強力な水攻撃' },
            { id: 8, name: '津波', element: ELEMENTS.WATER, damage: 4, description: '全体攻撃' },
            { id: 9, name: '水の癒し', element: ELEMENTS.WATER, damage: 0, description: 'HP2回復' },
            { id: 10, name: '凍結', element: ELEMENTS.WATER, damage: 1, description: '行動不可効果' },
            
            // 風属性カード
            { id: 11, name: '突風', element: ELEMENTS.WIND, damage: 2, description: '基本的な風攻撃' },
            { id: 12, name: '竜巻', element: ELEMENTS.WIND, damage: 3, description: '手札シャッフル' },
            { id: 13, name: '嵐', element: ELEMENTS.WIND, damage: 4, description: '手札破棄効果' },
            { id: 14, name: '疾風', element: ELEMENTS.WIND, damage: 1, description: 'カードドロー' },
            { id: 15, name: '風の加護', element: ELEMENTS.WIND, damage: 0, description: '状態異常解除' },
            
            // 土属性カード
            { id: 16, name: '岩石投げ', element: ELEMENTS.EARTH, damage: 2, description: '基本的な土攻撃' },
            { id: 17, name: '地震', element: ELEMENTS.EARTH, damage: 3, description: '全体攻撃' },
            { id: 18, name: '落石', element: ELEMENTS.EARTH, damage: 4, description: '行動封印' },
            { id: 19, name: '土の壁', element: ELEMENTS.EARTH, damage: 0, description: 'HP増加' },
            { id: 20, name: '砂嵐', element: ELEMENTS.EARTH, damage: 1, description: '視界妨害' },
            
            // 雷属性カード
            { id: 21, name: '雷撃', element: ELEMENTS.THUNDER, damage: 2, description: '基本的な雷攻撃' },
            { id: 22, name: '落雷', element: ELEMENTS.THUNDER, damage: 4, description: '麻痺効果' },
            { id: 23, name: '稲妻', element: ELEMENTS.THUNDER, damage: 3, description: '連鎖攻撃' },
            { id: 24, name: '電撃網', element: ELEMENTS.THUNDER, damage: 1, description: '全体攻撃' },
            { id: 25, name: '充電', element: ELEMENTS.THUNDER, damage: 0, description: '次回ダメージ強化' },
            
            // 氷属性カード
            { id: 26, name: '氷の矢', element: ELEMENTS.ICE, damage: 2, description: '基本的な氷攻撃' },
            { id: 27, name: '吹雪', element: ELEMENTS.ICE, damage: 3, description: '行動速度低下' },
            { id: 28, name: '氷河', element: ELEMENTS.ICE, damage: 4, description: '長時間凍結' },
            { id: 29, name: '霜', element: ELEMENTS.ICE, damage: 1, description: 'ダメージ減少' },
            { id: 30, name: '氷の盾', element: ELEMENTS.ICE, damage: 0, description: '攻撃無効化' }
        ];

        // サーバー接続
        function initializeSocket() {
            // 実際のプロダクションでは実際のサーバーURLを使用
            const serverUrl = 'wss://skillwar-server.onrender.com';
            
            try {
                socket = io(serverUrl, {
                    transports: ['websocket', 'polling'],
                    upgrade: true,
                    rememberUpgrade: true
                });

                setupSocketListeners();
            } catch (error) {
                console.warn('WebSocketサーバーに接続できませんでした。デモモードで動作します。');
                initializeDemoMode();
            }
        }

        function initializeDemoMode() {
            // デモモード: ローカルでのシミュレーション
            socket = new EventTarget();
            socket.connected = false;
            
            // WebSocketのメソッドをシミュレート
            socket.emit = function(event, data) {
                setTimeout(() => {
                    handleDemoEvent(event, data);
                }, Math.random() * 1000 + 500);
            };

            socket.on = function(event, callback) {
                this.addEventListener(event, (e) => {
                    callback(e.detail);
                });
            };

            updateConnectionStatus(false);
            showActionFeedback('デモモードで動作中（オフライン）', 'error');
        }

        function handleDemoEvent(event, data) {
            switch (event) {
                case 'createRoom':
                    const room = {
                        id: generateRoomId(),
                        name: data.roomName,
                        maxPlayers: data.maxPlayers,
                        players: [data.player],
                        isStarted: false
                    };
                    gameState.currentRoom = room;
                    gameState.currentPlayer = data.player;
                    socket.dispatchEvent(new CustomEvent('roomCreated', { detail: { room, player: data.player } }));
                    break;
                    
                case 'joinRoom':
                    // デモ用の自動NPCプレイヤー追加
                    const demoRoom = {
                        id: data.roomId,
                        name: 'デモルーム',
                        maxPlayers: 4,
                        players: [
                            { id: 'demo1', name: 'デモプレイヤー1', isReady: false, isHost: true, index: 0 },
                            data.player
                        ],
                        isStarted: false
                    };
                    gameState.currentRoom = demoRoom;
                    gameState.currentPlayer = data.player;
                    socket.dispatchEvent(new CustomEvent('roomJoined', { detail: { room: demoRoom, player: data.player } }));
                    break;
                    
                case 'toggleReady':
                    gameState.currentPlayer.isReady = !gameState.currentPlayer.isReady;
                    // NPCも自動で準備完了
                    setTimeout(() => {
                        gameState.currentRoom.players.forEach(p => {
                            if (p.id.startsWith('demo')) p.isReady = true;
                        });
                        socket.dispatchEvent(new CustomEvent('roomUpdated', { detail: { room: gameState.currentRoom } }));
                    }, 1000);
                    break;
                    
                case 'startGame':
                    const gamePlayers = gameState.currentRoom.players.map((player, index) => ({
                        ...player,
                        hp: 10,
                        maxHp: 10,
                        hand: generateInitialHand(),
                        statusEffects: [],
                        isAlive: true,
                        possessedBy: null,
                        stunned: false
                    }));
                    
                    socket.dispatchEvent(new CustomEvent('gameStarted', { 
                        detail: { 
                            players: gamePlayers,
                            currentPlayerIndex: 0,
                            turnNumber: 1
                        } 
                    }));
                    break;
                    
                case 'playerAction':
                    processPlayerAction(data);
                    break;
            }
        }

        function generateInitialHand() {
            const hand = [];
            for (let i = 0; i < 5; i++) {
                const randomCard = CARD_DATABASE[Math.floor(Math.random() * CARD_DATABASE.length)];
                hand.push({...randomCard, instanceId: Math.random().toString(36).substr(2, 9)});
            }
            return hand;
        }

        function generateRoomId() {
            return Math.random().toString(36).substr(2, 6).toUpperCase();
        }

        function setupSocketListeners() {
            socket.on('connect', () => {
                console.log('サーバーに接続されました');
                gameState.playerId = socket.id;
                updateConnectionStatus(true);
                document.getElementById('my-player-id').textContent = socket.id;
            });

            socket.on('disconnect', () => {
                console.log('サーバーから切断されました');
                updateConnectionStatus(false);
                showActionFeedback('サーバーから切断されました', 'error');
            });

            socket.on('roomsList', (rooms) => {
                updateRoomsList(rooms);
            });

            socket.on('roomCreated', (data) => {
                gameState.currentRoom = data.room;
                gameState.currentPlayer = data.player;
                showWaitingScreen();
                showActionFeedback('部屋が作成されました！', 'success');
            });

            socket.on('roomJoined', (data) => {
                gameState.currentRoom = data.room;
                gameState.currentPlayer = data.player;
                showWaitingScreen();
                showActionFeedback('部屋に参加しました！', 'success');
            });

            socket.on('roomUpdated', (data) => {
                gameState.currentRoom = data.room;
                updateWaitingRoom();
            });

            socket.on('gameStarted', (data) => {
                gameState.players = data.players;
                gameState.currentPlayerIndex = data.currentPlayerIndex;
                gameState.turnNumber = data.turnNumber;
                gameState.phase = 'battle';
                gameState.isMyTurn = data.currentPlayerIndex === gameState.currentPlayer.index;
                showGameScreen();
                startTurnTimer();
            });

            socket.on('turnChanged', (data) => {
                gameState.currentPlayerIndex = data.currentPlayerIndex;
                gameState.turnNumber = data.turnNumber;
                gameState.isMyTurn = gameState.players[data.currentPlayerIndex].id === gameState.playerId;
                updateGameDisplay();
                resetTurnTimer();
            });

            socket.on('actionPerformed', (data) => {
                applyGameAction(data);
                updateGameDisplay();
            });

            socket.on('gameEnded', (data) => {
                showGameEndScreen(data.rankings);
            });

            socket.on('error', (error) => {
                console.error('Socket error:', error);
                showActionFeedback(`エラー: ${error.message}`, 'error');
            });
        }

        // 部屋管理関数
        function createRoom() {
            const playerName = document.getElementById('player-name').value.trim() || 'プレイヤー1';
            const roomName = document.getElementById('room-name').value.trim() || `${playerName}の部屋`;
            const maxPlayers = parseInt(document.getElementById('max-players').value);

            const player = {
                id: gameState.playerId || generateRoomId(),
                name: playerName,
                isReady: false,
                isHost: true,
                index: 0
            };

            if (socket && socket.connected) {
                socket.emit('createRoom', {
                    roomName: roomName,
                    maxPlayers: maxPlayers,
                    player: player
                });
            } else {
                socket.emit('createRoom', {
                    roomName: roomName,
                    maxPlayers: maxPlayers,
                    player: player
                });
            }
        }

        function joinRoom(roomId) {
            const playerName = document.getElementById('player-name').value.trim() || 'プレイヤー1';
            
            const player = {
                id: gameState.playerId || generateRoomId(),
                name: playerName,
                isReady: false,
                isHost: false
            };

            if (socket && socket.connected) {
                socket.emit('joinRoom', {
                    roomId: roomId,
                    player: player
                });
            } else {
                socket.emit('joinRoom', {
                    roomId: roomId,
                    player: player
                });
            }
        }

        function joinRoomById() {
            const roomId = document.getElementById('room-id-input').value.trim();
            if (!roomId) {
                showActionFeedback('部屋IDを入力してください', 'error');
                return;
            }
            joinRoom(roomId);
        }

        function leaveRoom() {
            if (socket && socket.connected) {
                socket.emit('leaveRoom', {
                    roomId: gameState.currentRoom.id,
                    playerId: gameState.playerId
                });
            }
            
            gameState.currentRoom = null;
            gameState.currentPlayer = null;
            showRoomScreen();
            showActionFeedback('部屋を出ました', 'success');
        }

        function refreshRooms() {
            if (socket && socket.connected) {
                socket.emit('getRooms');
            } else {
                updateRoomsList([
                    { id: 'demo1', name: 'デモルーム1', players: 2, maxPlayers: 4 },
                    { id: 'demo2', name: 'デモルーム2', players: 1, maxPlayers: 3 },
                    { id: 'demo3', name: 'デモルーム3', players: 3, maxPlayers: 6 }
                ]);
            }
        }

        function toggleReady() {
            if (!gameState.currentPlayer) return;

            if (socket && socket.connected) {
                socket.emit('toggleReady', {
                    roomId: gameState.currentRoom.id,
                    playerId: gameState.playerId
                });
            } else {
                socket.emit('toggleReady', {
                    roomId: gameState.currentRoom.id,
                    playerId: gameState.currentPlayer.id
                });
            }
        }

        function startOnlineGame() {
            if (!gameState.currentPlayer.isHost) {
                showActionFeedback('ホストのみがゲームを開始できます', 'error');
                return;
            }

            if (socket && socket.connected) {
                socket.emit('startGame', {
                    roomId: gameState.currentRoom.id
                });
            } else {
                socket.emit('startGame', {
                    roomId: gameState.currentRoom.id
                });
            }
        }

        // 画面表示関数
        function showRoomScreen() {
            document.getElementById('room-screen').style.display = 'block';
            document.getElementById('waiting-screen').style.display = 'none';
            document.getElementById('game-screen').style.display = 'none';
            refreshRooms();
        }

        function showWaitingScreen() {
            document.getElementById('room-screen').style.display = 'none';
            document.getElementById('waiting-screen').style.display = 'block';
            document.getElementById('game-screen').style.display = 'none';
            updateWaitingRoom();
        }

        function showGameScreen() {
            document.getElementById('room-screen').style.display = 'none';
            document.getElementById('waiting-screen').style.display = 'none';
            document.getElementById('game-screen').style.display = 'block';
            updateGameDisplay();
            addToLog('オンラインゲームが開始されました！');
        }

        function updateRoomsList(rooms) {
            const container = document.getElementById('available-rooms');
            container.innerHTML = '';

            if (rooms.length === 0) {
                container.innerHTML = '<p>現在利用可能な部屋はありません</p>';
                return;
            }

            rooms.forEach(room => {
                const roomDiv = document.createElement('div');
                roomDiv.className = 'room-item';
                
                const isFull = room.players >= room.maxPlayers;
                const joinButton = isFull ? 
                    '<button class="btn btn-secondary" disabled>満室</button>' :
                    `<button class="btn btn-secondary" onclick="joinRoom('${room.id}')">参加</button>`;
                
                roomDiv.innerHTML = `
                    <div class="room-info">
                        <div class="room-name">${room.name}</div>
                        <div class="room-players">${room.players}/${room.maxPlayers}人</div>
                    </div>
                    ${joinButton}
                `;
                container.appendChild(roomDiv);
            });
        }

        function updateWaitingRoom() {
            const room = gameState.currentRoom;
            if (!room) return;

            document.getElementById('room-title').textContent = room.name;
            document.getElementById('room-code').textContent = `部屋ID: ${room.id}`;

            const playersContainer = document.getElementById('players-in-room');
            playersContainer.innerHTML = '';

            room.players.forEach(player => {
                const playerDiv = document.createElement('div');
                playerDiv.className = 'player-item';
                
                const readyStatus = player.isReady ? 
                    '<span class="player-ready">✓ 準備完了</span>' : 
                    '<span class="player-waiting">⏳ 待機中</span>';
                
                const hostBadge = player.isHost ? ' 👑' : '';
                const meBadge = player.id === gameState.playerId ? ' (あなた)' : '';

                playerDiv.innerHTML = `
                    <div>${player.name}${hostBadge}${meBadge}</div>
                    <div>${readyStatus}</div>
                `;
                playersContainer.appendChild(playerDiv);
            });

            // 準備ボタンの状態更新
            const readyButton = document.getElementById('ready-toggle');
            if (gameState.currentPlayer.isReady) {
                readyButton.textContent = '準備解除';
                readyButton.className = 'btn btn-secondary';
            } else {
                readyButton.textContent = '準備完了';
                readyButton.className = 'btn btn-success';
            }

            // 全員準備完了チェック（ホストのみ）
            if (gameState.currentPlayer.isHost) {
                const allReady = room.players.every(p => p.isReady);
                const minPlayers = room.players.length >= 2;
                
                if (allReady && minPlayers) {
                    document.getElementById('start-game-section').style.display = 'block';
                } else {
                    document.getElementById('start-game-section').style.display = 'none';
                }
            }
        }

        // ゲーム関数
        function updateGameDisplay() {
            updateGameStatus();
            updatePlayersGrid();
            updatePlayerHand();
            updateActionButtons();
        }

        function updateGameStatus() {
            document.getElementById('current-turn').textContent = gameState.turnNumber;
            const currentPlayer = gameState.players[gameState.currentPlayerIndex];
            document.getElementById('current-player-name').textContent = currentPlayer.name;
            document.getElementById('current-room-name').textContent = gameState.currentRoom.name;
        }

        function updatePlayersGrid() {
            const grid = document.getElementById('players-grid');
            grid.innerHTML = '';
            
            gameState.players.forEach((player, index) => {
                const playerCard = document.createElement('div');
                playerCard.className = `player-card ${index === gameState.currentPlayerIndex ? 'current-turn' : ''} ${!player.isAlive ? 'dead' : ''}`;
                
                const statusEffectsHtml = player.statusEffects.map(effect => 
                    `<span class="status-effect ${effect.element}">${ELEMENT_NAMES[effect.element]}(${effect.duration})</span>`
                ).join('');

                const isCurrentUser = player.id === gameState.playerId;
                const playerLabel = isCurrentUser ? `${player.name} (あなた)` : player.name;

                playerCard.innerHTML = `
                    <div class="player-name">${playerLabel}</div>
                    <div class="player-hp">HP: ${player.hp}/${player.maxHp}</div>
                    <div class="player-status">手札: ${player.hand.length}枚</div>
                    <div class="status-effects">${statusEffectsHtml}</div>
                `;
                
                grid.appendChild(playerCard);
            });
        }

        function updatePlayerHand() {
            const currentUser = gameState.players.find(p => p.id === gameState.playerId);
            if (!currentUser) return;

            const container = document.getElementById('hand-cards');
            container.innerHTML = '';
            
            document.getElementById('hand-count').textContent = currentUser.hand.length;

            currentUser.hand.forEach(card => {
                const cardElement = createCardElement(card, true);
                if (gameState.selectedCard && gameState.selectedCard.instanceId === card.instanceId) {
                    cardElement.classList.add('selected');
                }
                container.appendChild(cardElement);
            });
        }

        function createCardElement(card, clickable = false) {
            const cardDiv = document.createElement('div');
            cardDiv.className = `card ${card.element}`;
            if (clickable) {
                cardDiv.onclick = () => selectCard(card);
            }
            
            cardDiv.innerHTML = `
                <div class="card-name">${card.name}</div>
                <div class="card-description">${card.description}</div>
                <div class="card-damage">ダメージ: ${card.damage}</div>
                <div class="card-element">${ELEMENT_NAMES[card.element]}</div>
            `;
            
            return cardDiv;
        }

        function updateActionButtons() {
            const isMyTurn = gameState.isMyTurn;
            const currentUser = gameState.players.find(p => p.id === gameState.playerId);
            const isAlive = currentUser && currentUser.isAlive;
            
            document.getElementById('use-card-btn').disabled = !isMyTurn || !isAlive;
            document.getElementById('draw-card-btn').disabled = !isMyTurn || !isAlive;
        }

        function selectCard(card) {
            if (!gameState.isMyTurn) {
                showActionFeedback('あなたのターンではありません', 'error');
                return;
            }
            
            gameState.selectedCard = card;
            updatePlayerHand();
        }

        function selectAction(action) {
            if (!gameState.isMyTurn) {
                showActionFeedback('あなたのターンではありません', 'error');
                return;
            }
            
            if (action === 'useCard') {
                if (!gameState.selectedCard) {
                    showActionFeedback('カードを選択してください！', 'error');
                    return;
                }
                showTargetSelection();
            } else if (action === 'drawCard') {
                performAction({ type: 'drawCard' });
            }
        }

        function showTargetSelection() {
            document.getElementById('target-selection').style.display = 'block';
            const container = document.getElementById('target-players');
            container.innerHTML = '';
            
            gameState.players.forEach((player, index) => {
                if (player.isAlive) {
                    const button = document.createElement('button');
                    button.className = 'target-player';
                    button.textContent = `${player.name} (HP: ${player.hp})`;
                    button.onclick = () => selectTarget(index);
                    container.appendChild(button);
                }
            });
            
            document.getElementById('confirm-action-btn').style.display = 'block';
        }

        function selectTarget(playerIndex) {
            gameState.selectedTarget = playerIndex;
            
            // ハイライト更新
            document.querySelectorAll('.target-player').forEach(btn => {
                btn.classList.remove('selected');
            });
            event.target.classList.add('selected');
        }

        function confirmAction() {
            if (gameState.selectedCard && gameState.selectedTarget !== null) {
                performAction({
                    type: 'useCard',
                    card: gameState.selectedCard,
                    targetIndex: gameState.selectedTarget
                });
                
                // UI リセット
                gameState.selectedCard = null;
                gameState.selectedTarget = null;
                document.getElementById('target-selection').style.display = 'none';
                document.getElementById('confirm-action-btn').style.display = 'none';
            }
        }

        function performAction(actionData) {
            if (socket && socket.connected) {
                socket.emit('playerAction', {
                    roomId: gameState.currentRoom.id,
                    playerId: gameState.playerId,
                    action: actionData
                });
            } else {
                socket.emit('playerAction', {
                    roomId: gameState.currentRoom.id,
                    playerId: gameState.playerId || gameState.currentPlayer.id,
                    action: actionData
                });
            }
        }

        function processPlayerAction(data) {
            // デモモード用のアクション処理
            setTimeout(() => {
                socket.dispatchEvent(new CustomEvent('actionPerformed', { 
                    detail: data 
                }));
                
                // 次のターンに進む
                setTimeout(() => {
                    const nextPlayerIndex = (gameState.currentPlayerIndex + 1) % gameState.players.length;
                    const nextTurnNumber = nextPlayerIndex === 0 ? gameState.turnNumber + 1 : gameState.turnNumber;
                    
                    socket.dispatchEvent(new CustomEvent('turnChanged', { 
                        detail: { 
                            currentPlayerIndex: nextPlayerIndex,
                            turnNumber: nextTurnNumber
                        } 
                    }));
                }, 1500);
            }, 500);
        }

        function applyGameAction(data) {
            const { action, playerId } = data;
            const player = gameState.players.find(p => p.id === playerId);
            
            if (!player) return;
            
            if (action.type === 'drawCard') {
                const randomCard = CARD_DATABASE[Math.floor(Math.random() * CARD_DATABASE.length)];
                player.hand.push({...randomCard, instanceId: Math.random().toString(36).substr(2, 9)});
                addToLog(`${player.name}がカードを1枚引きました`);
                
            } else if (action.type === 'useCard') {
                const target = gameState.players[action.targetIndex];
                
                // カードを手札から削除
                player.hand = player.hand.filter(c => c.instanceId !== action.card.instanceId);
                
                // ダメージ適用
                if (action.card.damage > 0) {
                    target.hp = Math.max(0, target.hp - action.card.damage);
                    addToLog(`${player.name}が${target.name}に${action.card.name}を使用！${action.card.damage}ダメージ`);
                }
                
                // 特殊効果処理
                processCardEffects(action.card, target, player);
                
                // HP0チェック
                if (target.hp <= 0 && target.isAlive) {
                    target.isAlive = false;
                    addToLog(`${target.name}が倒れました！`);
                    
                    // ゲーム終了チェック
                    const alivePlayers = gameState.players.filter(p => p.isAlive);
                    if (alivePlayers.length <= 1) {
                        setTimeout(() => {
                            socket.dispatchEvent(new CustomEvent('gameEnded', {
                                detail: { rankings: createRankings() }
                            }));
                        }, 2000);
                    }
                }
            }
        }

        function processCardEffects(card, target, attacker) {
            // 属性状態付与
            if (card.element) {
                applyStatusEffect(target, card.element);
            }
            
            // カード固有効果
            switch (card.name) {
                case '水の癒し':
                    target.hp = Math.min(target.maxHp, target.hp + 2);
                    addToLog(`${target.name}のHPが2回復！`);
                    break;
                case '疾風':
                    const randomCard = CARD_DATABASE[Math.floor(Math.random() * CARD_DATABASE.length)];
                    attacker.hand.push({...randomCard, instanceId: Math.random().toString(36).substr(2, 9)});
                    addToLog(`${attacker.name}が追加でカードを1枚引いた！`);
                    break;
            }
        }

        function applyStatusEffect(player, element) {
            // 既存の同じ属性効果を除去
            player.statusEffects = player.statusEffects.filter(effect => effect.element !== element);
            
            // 新しい効果を追加
            player.statusEffects.push({
                element: element,
                duration: 2
            });
            
            // 最大2つまでの制限
            if (player.statusEffects.length > 2) {
                player.statusEffects.shift();
            }
            
            // 属性相性チェック
            checkElementalReactions(player);
        }

        function checkElementalReactions(player) {
            if (player.statusEffects.length < 2) return;
            
            const elements = player.statusEffects.map(effect => effect.element);
            const reactionKey = elements.join(',');
            const reverseKey = [...elements].reverse().join(',');
            
            const reaction = ELEMENT_REACTIONS[reactionKey] || ELEMENT_REACTIONS[reverseKey];
            
            if (reaction) {
                addToLog(`${player.name}に${reaction.name}が発生！`);
                
                // 属性状態をクリア
                player.statusEffects = [];
                
                // 反応効果を適用
                applyReactionEffect(player, reaction.effect);
            }
        }

        function applyReactionEffect(player, effect) {
            switch (effect) {
                case 'steam':
                case 'burn':
                    player.hp = Math.max(0, player.hp - 1);
                    if (player.hand.length > 0) {
                        const randomIndex = Math.floor(Math.random() * player.hand.length);
                        player.hand.splice(randomIndex, 1);
                        addToLog(`${player.name}の手札が1枚消滅！`);
                    }
                    break;
                case 'shock':
                case 'melt':
                case 'dissolve':
                    player.hp = Math.max(0, player.hp - 1);
                    player.stunned = true;
                    addToLog(`${player.name}は次のターンカードを使えません！`);
                    break;
                case 'overreaction':
                    player.hp = Math.max(0, player.hp - 2);
                    addToLog(`${player.name}は過剰反応により2ダメージ！`);
                    break;
                case 'erosion':
                    for (let i = 0; i < 3 && player.hand.length > 0; i++) {
                        const randomIndex = Math.floor(Math.random() * player.hand.length);
                        player.hand.splice(randomIndex, 1);
                    }
                    addToLog(`${player.name}の手札が3枚消滅！`);
                    break;
            }
        }

        function createRankings() {
            return [...gameState.players].sort((a, b) => {
                if (a.isAlive && !b.isAlive) return -1;
                if (!a.isAlive && b.isAlive) return 1;
                return b.hp - a.hp;
            });
        }

        function showGameEndScreen(rankings) {
            document.getElementById('game-over-screen').style.display = 'block';
            
            const rankingDiv = document.getElementById('final-ranking');
            rankingDiv.innerHTML = rankings.map((player, index) => 
                `<div><strong>${index + 1}位:</strong> ${player.name} (HP: ${player.hp}/${player.maxHp}) ${player.isAlive ? '🎉生存' : '💀死亡'}</div>`
            ).join('');
            
            addToLog('ゲーム終了！');
        }

        // ターンタイマー機能
        function startTurnTimer() {
            resetTurnTimer();
        }

        function resetTurnTimer() {
            clearInterval(gameState.turnTimer);
            gameState.turnTimeLeft = 30;
            
            if (gameState.isMyTurn) {
                document.getElementById('turn-timer').style.display = 'block';
                updateTimerDisplay();
                
                gameState.turnTimer = setInterval(() => {
                    gameState.turnTimeLeft--;
                    updateTimerDisplay();
                    
                    if (gameState.turnTimeLeft <= 0) {
                        // 時間切れで自動的にカードドロー
                        performAction({ type: 'drawCard' });
                    }
                }, 1000);
            } else {
                document.getElementById('turn-timer').style.display = 'none';
            }
        }

        function updateTimerDisplay() {
            document.getElementById('timer-seconds').textContent = gameState.turnTimeLeft;
        }

        // ユーティリティ関数
        function updateConnectionStatus(connected) {
            const statusEl = document.getElementById('connection-status');
            const textEl = document.getElementById('connection-text');
            
            if (connected) {
                statusEl.className = 'connection-status connected';
                textEl.textContent = '🟢 オンライン';
            } else {
                statusEl.className = 'connection-status disconnected';
                textEl.textContent = '🔴 オフライン';
            }
        }

        function showActionFeedback(message, type = 'success') {
            const feedbackDiv = document.getElementById('action-feedback');
            const className = type === 'error' ? 'action-feedback error-feedback' : 'action-feedback';
            feedbackDiv.innerHTML = `<div class="${className}">${message}</div>`;
            
            setTimeout(() => {
                feedbackDiv.innerHTML = '';
            }, 3000);
        }

        function addToLog(message) {
            const log = document.getElementById('game-log');
            const entry = document.createElement('div');
            entry.className = 'log-entry';
            entry.textContent = `[${new Date().toLocaleTimeString()}] ${message}`;
            log.appendChild(entry);
            log.scrollTop = log.scrollHeight;
        }

        function backToRooms() {
            clearInterval(gameState.turnTimer);
            gameState = {
                phase: 'rooms',
                currentRoom: null,
                currentPlayer: null,
                players: [],
                currentPlayerIndex: 0,
                turnNumber: 1,
                selectedCard: null,
                selectedTarget: null,
                isMyTurn: false,
                turnTimeLeft: 30,
                turnTimer: null,
                playerId: gameState.playerId
            };
            showRoomScreen();
        }

        // 初期化
        window.onload = function() {
            initializeSocket();
            showRoomScreen();
        };
  </script>
</body>
</html>
